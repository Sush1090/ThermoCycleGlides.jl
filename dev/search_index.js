var documenterSearchIndex = {"docs":
[{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here examples are shown on how to construct the system with parameters and how to solve it.","category":"page"},{"location":"examples/#Solver-and-Solution-parameters","page":"Examples","title":"Solver and Solution parameters","text":"","category":"section"},{"location":"examples/#Heat-Pump","page":"Examples","title":"Heat Pump","text":"","category":"section"},{"location":"examples/#Heat-Pump-with-IHEX","page":"Examples","title":"Heat Pump with IHEX","text":"","category":"section"},{"location":"examples/#Organic-Rankine-Cycle","page":"Examples","title":"Organic Rankine Cycle","text":"","category":"section"},{"location":"examples/#Organic-Rankine-Cycle-with-IHEX","page":"Examples","title":"Organic Rankine Cycle with IHEX","text":"","category":"section"},{"location":"reference/#References","page":"References","title":"References","text":"","category":"section"},{"location":"reference/#Contents","page":"References","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"References","title":"References","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"References","title":"Index","text":"","category":"section"},{"location":"reference/","page":"References","title":"References","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#ThermoCycleGlides.ORC","page":"References","title":"ThermoCycleGlides.ORC","text":"ORC{T<:Real} <: ThermoCycleProblem\n\nDefines an Organic Rankine Cycle (ORC) problem with thermodynamic and design  parameters specified in Kelvin and dimensionless efficiencies.\n\nFields\n\nfluid::EoSModel: Equation of State (EoS) model representing the working fluid.\nz::AbstractVector{T}: Mole fraction composition vector of the working fluid.\nT_evap_in::T: Inlet temperature of the evaporator [K].\nT_evap_out::T: Outlet temperature of the evaporator [K].\nΔT_sh::T: Degree of superheating at the expander inlet [K].\nT_cond_in::T: Inlet temperature of the condenser [K].\nT_cond_out::T: Outlet temperature of the condenser [K].\nΔT_sc::T: Degree of subcooling at the pump inlet [K].\nη_pump::T: Isentropic efficiency of the pump [-].\nη_expander::T: Isentropic efficiency of the expander [-].\npp_evap::T: Minimum temperature difference (pinch point) at the evaporator [K].\npp_cond::T: Minimum temperature difference (pinch point) at the condenser [K].\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.ORCEconomizer","page":"References","title":"ThermoCycleGlides.ORCEconomizer","text":"    ORCEconomizer{T<:Real} <: ThermoCycleProblem\n\nDefines an Organic Rankine Cycle (ORC) configuration with an economiser (regenerative heat exchanger), extending the base ORC problem with a specified effectiveness.\n\nFields\n\norc::ORC{T}: Base ORC system definition containing the thermodynamic parameters.\nϵ::T: Effectiveness of the economiser (regenerator) [-].\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.SolutionState","page":"References","title":"ThermoCycleGlides.SolutionState","text":"SolutionState -  A struct to hold the solution state of the nonlinear solver.\n\nx::Vector{T}: The solution vector.\nf_calls::I: The number of function calls made during the solving process.\niterations::I: The number of iterations taken to converge.\nresiduals::Vector{T}: The residuals at the solution.\nlb::Vector{T}: The lower bounds used in the solver.\nub::Vector{T}: The upper bounds used in the solver.\nautodiff::Bool: A flag indicating whether automatic differentiation was used.\nfd_order::I: The order of finite difference used if autodiff is false.\nlenx::T: The final change in the solution vector.\nlenf::T: The final change in the residuals.\nsoltype::Symbol: A symbol indicating the type of cycle (:unknown,:subcritical,:transcritical). This will be updated with the cycle type after solving.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.ThermoCycleParameters","page":"References","title":"ThermoCycleGlides.ThermoCycleParameters","text":"ThermoCycleParameters -  A struct to hold the solver parameters of the nonlinear solver.\n\nN::Int: Heat Exchanger discretization.\nmax_iters::Int: Maximum number of iterations\nautodiff::Bool: A flag indicating whether automatic differentiation was used.\nfd_order::Int: The order of finite difference used if autodiff is false.\nxtol::Real: convergece criteria on x.\nftol::Real: convergece criteria on f.\nrestart_TOL::Real: Restrat strategy with tolerace.\ninternal_pinch::Bool : Check for interal pinch for mixtures\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.COP-Tuple{ThermoCycleGlides.ThermoCycleProblem, SolutionState}","page":"References","title":"ThermoCycleGlides.COP","text":"COP(prob::ThermoCycleGlides.ThermoCycleProblem, sol::SolutionState) -> Float64\n\nComputes the coefficient of performance (COP) of a thermodynamic cycle given the  problem definition and its corresponding solution state.\n\nArguments\n\nprob::ThermoCycleGlides.ThermoCycleProblem: The thermodynamic cycle problem  containing fluid models, boundary conditions, and component parameters.\nsol::SolutionState: The solution state object containing the converged  state variables (x), residuals, and convergence information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{HeatPumpRecuperator}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::HeatPumpRecuperator) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{HeatPump}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::HeatPump) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{ORCEconomizer}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::ORCEconomizer) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{ORC}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::ORC) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{HeatPump, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::HeatPump,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{HeatPumpRecuperator, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::HeatPumpRecuperator,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{ORC, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::ORC,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{ORCEconomizer, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::ORCEconomizer,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.optimize-Tuple{ThermoCycleGlides.ThermoCycleProblem, Metaheuristics.Algorithm}","page":"References","title":"ThermoCycleGlides.optimize","text":"optimize(prob::ThermoCycleProblem; kwargs...)\n\nIts goal is to find the optimal subcooling and superheating values that maximize the cycle performance (COP or ORC -efficiency).\n\nThis should return the optimized cycle struct and the result from Metaheuristics\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.plot_cycle-Tuple{HeatPump, AbstractVector}","page":"References","title":"ThermoCycleGlides.plot_cycle","text":"Plots TS diagram\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.power_ratings-Union{Tuple{T}, Tuple{HeatPump, AbstractVector{T}}} where T","page":"References","title":"ThermoCycleGlides.power_ratings","text":"Function that gives specific power ratings for HP by fixing outlet power of compressor to equal 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.power_ratings-Union{Tuple{T}, Tuple{HeatPumpRecuperator, AbstractVector{T}}} where T","page":"References","title":"ThermoCycleGlides.power_ratings","text":"Function that gives specific power ratings for HP by fixing outlet power of compressor to equal 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.power_ratings-Union{Tuple{T}, Tuple{ORC, AbstractVector{T}}} where T","page":"References","title":"ThermoCycleGlides.power_ratings","text":"Function that gives specific power ratings for ORC by fixing outlet power of expander to equal 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.show_parameters-Tuple{ORC}","page":"References","title":"ThermoCycleGlides.show_parameters","text":"show_parameters(prob::ORC) prints parameters in REPL\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.solve-Tuple{ThermoCycleGlides.ThermoCycleProblem, ThermoCycleParameters}","page":"References","title":"ThermoCycleGlides.solve","text":"Solves for pressure values in HP and ORC cycles for the given glide and problem parameters. \nDefine those problems in the respective structs. \nFor now the default box-nonlinear solver is newton-raphson, but this can be changed to other solvers in the future.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.solve-Tuple{ThermoCycleGlides.ThermoCycleProblem}","page":"References","title":"ThermoCycleGlides.solve","text":"Solves for pressure values in HP and ORC cycles for the given glide and problem parameters. \nDefine those problems in the respective structs. \nFor now the default box-nonlinear solver is newton-raphson, but this can be changed to other solvers in the future.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.η-Tuple{ThermoCycleGlides.ThermoCycleProblem, SolutionState}","page":"References","title":"ThermoCycleGlides.η","text":"η(prob::ThermoCycleGlides.ThermoCycleProblem, sol::SolutionState) -> Float64\n\nComputes the thermal efficiency of a thermodynamic cycle given a problem definition  and its corresponding solution state.\n\nArguments\n\nprob::ThermoCycleGlides.ThermoCycleProblem: The thermodynamic cycle problem  containing fluid properties, boundary conditions, and component parameters.\nsol::SolutionState: The solution state object containing the converged  state variables (x), residuals, and convergence information.\n\nReturns\n\nFloat64: The computed cycle efficiency, defined as the ratio of net work  output to heat input.\n\nNotes\n\nThis method acts as a wrapper that extracts the solution vector x from  sol and calls the lower-level η(prob, x) implementation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.η-Union{Tuple{T}, Tuple{ORC, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.η","text":"p[1] -> condensor pressure p[2] -> evaporator pressure\n\n\n\n\n\n","category":"method"},{"location":"#ThermoCycleGlides.jl","page":"Home","title":"ThermoCycleGlides.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation of ThermoCycleGlides.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The goal of this package is to have the non-linear solver for Heat Pump and Organic Rankine Cycle systems. It solves for pressures at evaporator and condensor for given pinch-point temperatures as well as provides plotting framework of the solution.  As of now the package is robust for subcritical cycle parameters. For thermodynamic properties, Clapeyron.jl is used as backend. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For details of modeling see: Carnot batteries for heat and power coupling: Energy, Exergy, Economic and Environmental (4E) analysis - Laterre, Antoine, which is describes modeling for pure fluids while this package also implements it for mixtures. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The nonlinear solver chosen is Newton-Raphson with box bounds which is inspired by the implementation in NLboxsolve.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is for steady-state applications.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are 4 systems provided: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Organic Rankine Cycle : ORC\nOrganic Rankine Cycle with internal heat exchanger : ORCEconomizer\nHeat Pump : HeatPump\nHeat Pump with internal heat exchanger : HeatPumpRecuperator ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The implemented version of these systems consist of the following components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Compressor : Modeled with isentropic efficiency   \nExpander : Modeled with isentropic efficiency\nValue : Modeled as isenthalpic process\nEvaporator : Volumes of equal change in enthalpy.\nCondensor : Volumes of equal change in enthalpy.\nHeat Exchangers (no phase change) : using epsilon as effectivness of heat exchanger. ","category":"page"}]
}
