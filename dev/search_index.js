var documenterSearchIndex = {"docs":
[{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"Cycle optimization is integrated with Metaheuristics.jl. The goal of the inbuilt optimization is to find optimal superheating and subcooling temperatures for a given cycle. \n\nHere an example of HeatPump is shown.\n\nWe set our HeatPump\n\nusing Clapeyron, ThermoCycleGlides,Metaheuristics\n\nfluid = cPR(\"propane\",idealmodel = ReidIdeal)\nhp = HeatPump(fluid=fluid, z=[1.0], T_evap_in=310, T_evap_out=300.0, T_cond_in=325, T_cond_out=355, η_comp=0.75, pp_evap=5, pp_cond=5, ΔT_sc=5.0, ΔT_sh=5.0)\n\nWe load the algorithm and its parameters from Metaheuristics.jl:\n\noptions = Metaheuristics.Options(f_tol_rel = 1e-2, f_tol = 1e-2,f_calls_limit = 1000,parallel_evaluation = false,verbose = true)\n\nalgo = ECA(options = options)\n\nWe optimize the system\n\nresult,hp_optimized = ThermoCycleGlides.optimize(hp,algo; autodiff = true,N = 20,lower = 2.0,tol = 1e-3)\n\n+-----------+------------+------------+------------+------------+\n| Iteration | Num. Evals |   Minimum  |    Time    | Converged  |\n+-----------+------------+------------+------------+------------+\n|         1 |         14 | -3.2777e+00 |   0.1310 s |         No |\n|         2 |         28 | -3.2777e+00 |   0.2390 s |         No | \n|         3 |         42 | -3.6478e+00 |   0.3530 s |         No | \n|         4 |         56 | -3.6478e+00 |   0.4640 s |         No | \n|         5 |         70 | -3.6715e+00 |   0.5840 s |         No | \n|         6 |         84 | -4.0781e+00 |   0.7110 s |         No | \n|         7 |         98 | -4.0781e+00 |   0.8110 s |         No | \n|         8 |        112 | -4.0781e+00 |   0.9100 s |         No | \n|         9 |        126 | -4.0781e+00 |   1.0160 s |         No | \n|        10 |        140 | -4.0917e+00 |   1.1300 s |         No | \n|        11 |        154 | -4.0917e+00 |   1.2640 s |         No | \n|        12 |        168 | -4.0998e+00 |   1.3900 s |         No | \n|        13 |        182 | -4.1010e+00 |   1.5340 s |         No | \n|        14 |        196 | -4.1019e+00 |   1.6970 s |         No | \n|        15 |        210 | -4.1019e+00 |   1.8340 s |         No | \n|        16 |        224 | -4.1268e+00 |   1.9640 s |         No | \n|        17 |        238 | -4.1268e+00 |   2.1000 s |         No | \n|        18 |        252 | -4.1273e+00 |   2.2320 s |         No | \n|        19 |        266 | -4.1273e+00 |   2.3570 s |         No | \n|        20 |        280 | -4.1373e+00 |   2.4660 s |         No | \n|        21 |        294 | -4.1373e+00 |   2.5780 s |         No | \n|        22 |        308 | -4.1391e+00 |   2.6700 s |         No | \n|        23 |        322 | -4.1396e+00 |   2.7720 s |         No | \n|        24 |        336 | -4.1396e+00 |   2.8680 s |         No | \n|        25 |        350 | -4.1406e+00 |   2.9700 s |         No | \n|        26 |        364 | -4.1406e+00 |   3.0870 s |         No | \n|        27 |        378 | -4.1406e+00 |   3.1900 s |         No | \n|        28 |        392 | -4.1407e+00 |   3.2880 s |         No | \n|        29 |        406 | -4.1408e+00 |   3.3750 s |         No | \n|        30 |        420 | -4.1408e+00 |   3.4640 s |         No | \n|        31 |        434 | -4.1408e+00 |   3.5480 s |         No | \n|        32 |        448 | -4.1408e+00 |   3.6400 s |         No | \n|        33 |        462 | -4.1408e+00 |   3.7350 s |         No | \n|        34 |        476 | -4.1409e+00 |   3.8430 s |         No | \n|        35 |        490 | -4.1409e+00 |   3.9330 s |         No | \n|        36 |        504 | -4.1409e+00 |   4.0190 s |         No | \n|        37 |        518 | -4.1409e+00 |   4.0990 s |         No | \n|        38 |        532 | -4.1409e+00 |   4.1870 s |         No | \n|        39 |        546 | -4.1409e+00 |   4.2770 s |         No | \n|        40 |        560 | -4.1409e+00 |   4.3780 s |         No | \n|        41 |        574 | -4.1409e+00 |   4.4790 s |         No | \n|        42 |        588 | -4.1409e+00 |   4.5830 s |         No | \n|        43 |        602 | -4.1409e+00 |   4.6910 s |         No | \n|        44 |        616 | -4.1409e+00 |   4.7910 s |         No | \n|        45 |        630 | -4.1409e+00 |   4.9250 s |         No | \n|        46 |        644 | -4.1409e+00 |   5.0420 s |         No | \n|        47 |        658 | -4.1409e+00 |   5.1370 s |         No | \n|        48 |        672 | -4.1409e+00 |   5.2410 s |         No | \n|        49 |        686 | -4.1409e+00 |   5.3260 s |         No | \n|        50 |        700 | -4.1409e+00 |   5.4270 s |         No | \n|        51 |        714 | -4.1409e+00 |   5.5190 s |         No | \n|        52 |        728 | -4.1409e+00 |   5.6230 s |         No | \n|        53 |        742 | -4.1409e+00 |   5.7060 s |         No | \n|        54 |        756 | -4.1409e+00 |   5.7910 s |         No | \n|        55 |        770 | -4.1409e+00 |   5.8850 s |         No | \n|        56 |        784 | -4.1409e+00 |   5.9860 s |         No | \n|        57 |        798 | -4.1409e+00 |   6.0820 s |         No | \n|        58 |        812 | -4.1409e+00 |   6.1680 s |         No | \n|        59 |        826 | -4.1409e+00 |   6.2600 s |         No | \n|        60 |        840 | -4.1409e+00 |   6.3610 s |         No | \n|        61 |        854 | -4.1409e+00 |   6.4660 s |         No | \n|        62 |        868 | -4.1409e+00 |   6.5540 s |         No | \n|        63 |        882 | -4.1409e+00 |   6.6350 s |         No | \n|        64 |        896 | -4.1409e+00 |   6.7290 s |         No | \n|        65 |        910 | -4.1409e+00 |   6.8210 s |         No | \n|        66 |        924 | -4.1409e+00 |   6.9100 s |        Yes | \n(Optimization Result\n===================\n  Iteration:       66\n  Minimum:         -4.14088\n  Minimizer:       [10.0, 24.0863]\n  Function calls:  924\n  Total time:      6.9100 s\n  Stop reason:     Due to Convergence Termination criterion.\n\nTo plot the cycle we do as before but now the optimized cycle is already returned by the optimize function - hp_optimized\n\nNote: This is a metaheuristic method hence the converged answer for the user for this case can slighty be different based on number of function calls , time, solution etc ..\n\nsol = solve(hp_optimized,autodiff = true,N = 20,xtol = 1e-6,ftol = 1e-6,max_iter= 1000);\nplot_cycle(hp_optimized,sol;N = 300)\n\nThe HeatPump cycle before optimization had a COP of -3.23\n\n(Image: hp_pre_opt)\n\nAfter optimization of superheating and subcooling temperatures the COP is -4.14 (Image: hp_opt)","category":"section"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"These examples show how to construct the system with parameters and how to solve it.\n\nNote In all examples z denotes the number of moles, for mixtures ensure length(z) is same as the number of fluid components. ","category":"section"},{"location":"examples/#Heat-Pump","page":"Examples","title":"Heat Pump","text":"The goal of a heat pump is to heat up the secondary fluid of the condenser with some input of energy. See Heat pump and Refrigeration cycle.\n\n(Image: hp_example)\n\nTo construct the system, do the following:\n\njulia> using Clapeyron, ThermoCycleGlides\n\njulia> fluid = cPR([\"cyclopentane\"],idealmodel = ReidIdeal);\n\njulia> η_comp = 0.75; pp_cond = 2; pp_evap = 2;\n\njulia> T_evap_in = 273.15 + 10; T_evap_out = 273.15 + 0; T_cond_in = 273.15 + 50;  T_cond_out = 273.15+60;\n\njulia> ΔT_sc = 3; ΔT_sh = 10;\n\njulia> hp = HeatPump(fluid=fluid,z=[1.0],T_evap_in=T_evap_in,T_evap_out = T_evap_out,T_cond_in = T_cond_in,T_cond_out=T_cond_out,η_comp=η_comp,pp_evap=pp_evap,pp_cond=pp_cond,ΔT_sc = ΔT_sc,ΔT_sh = ΔT_sh);\n\njulia> sol_hp = solve(hp)\nSolutionState{Float64, Int64}([0.12829257763187535, 1.4551588056895837], 16, 7, [0.0, 5.684341886080802e-14], [0.07660159441435545, 0.07660159441435545], [1.6566058479359296, 1.6566058479359296], true, 0, 2.5468671054250572e-15, 8.038873388460929e-14)\n \njulia> COP(hp,sol_hp)\n-3.735868783526992\n\nNote: COP is Coefficient of Performance of the Heat Pump, it is negative as we see change of enthalpy of the working fluid which is negative in the condenser.\n\nTo plot do the following:\n\nplot_cycle(hp,sol_hp,N=300)\n\n(Image: HP_cyclopentane)","category":"section"},{"location":"examples/#Heat-Pump-with-IHEX","page":"Examples","title":"Heat Pump with IHEX","text":"Now the same heatpump with an internal heat exchanger of effectiveness (epsilon) of 0.7 can be constructed as follows:\n\n(Image: HP_recuperator_cyclopentane)\n\njulia> hp_ihex = HeatPumpRecuperator(hp=hp,ϵ=0.7);\n\njulia> sol_ihex = solve(hp_ihex)\nSolutionState{Float64, Int64}([0.12829257763131544, 1.4173574009406653], 8, 4, [3.524291969370097e-12, 8.827782949083485e-11], [0.07660159441435545, 0.07660159441435545], [1.6566058479359296, 1.6566058479359296], true, 0, 2.9326582172085184e-7, 8.83481511606116e-11, :subcritical)\n\njulia> COP(hp_ihex,sol_ihex)\n-3.8122385181795906\n\n(Image: HP_recupuerator_cycle)","category":"section"},{"location":"examples/#Organic-Rankine-Cycle","page":"Examples","title":"Organic Rankine Cycle","text":"An Organic Rankine Cycle aims to generate electricity from heating the working fluid, and passing it through an expander. See Organic Rankine Cycle for more information.\n\n(Image: orc_example)\n\njulia> fluid = cPR([\"propane\"],idealmodel = ReidIdeal);\n\njulia> orc = ORC(fluid = fluid,z = [1.0], T_evap_in = 360, T_evap_out = 340, T_cond_in = 280, T_cond_out = 290, η_expander = 0.75, η_pump = 0.8, ΔT_sh = 7.0, ΔT_sc= 3.0, pp_evap = 3.0, pp_cond = 3)\nORC{Float64}(PR{ReidIdeal, TwuAlpha, NoTranslation, vdW1fRule}(\"Propane\"), [1.0], 360.0, 340.0, 7.0, 280.0, 290.0, 3.0, 0.8, 0.75, 3.0, 3.0)\n\njulia> sol = solve(orc,ThermoCycleParameters())\nSolutionState{Float64, Int64}([27.24650730390755, 8.310317972863196], 6, 3, [1.943476490851026e-10, -2.1819346329721157e-8], [19.921551772573725, 6.969208543698516], [29.511108921525086, 9.094386318669063], true, 0, 1.1554874341578823e-5, 2.1820211851973873e-8, :subcritical)\n\njulia> η(orc,sol)\n-0.08885630488485266\n\nNote: Here, the efficiency is also negative as there is an enthalpy drop of the working fluid in the expander while there is an enthalpy gain in the evaporator. \n\nTo plot the ORC cycle: \n\njulia> plot_cycle(orc,sol,N=300)\n\n(Image: orc_propane)","category":"section"},{"location":"examples/#Organic-Rankine-Cycle-with-IHEX","page":"Examples","title":"Organic Rankine Cycle with IHEX","text":"As for the heatpump we now construct the ORC with internal heat exchanger. \n\n(Image: ORC_economizer_example)\n\njulia> orc_ihex = ORCEconomizer(orc=orc,ϵ=0.7);\n\njulia> sol_ihex = solve(orc_ihex,ThermoCycleParameters())\nSolutionState{Float64, Int64}([26.973845637899313, 8.391221086633655], 6, 3, [3.3583091862965375e-10, -3.281326144133345e-8], [19.921551772573725, 6.969208543698516], [29.511108921525086, 9.094386318669063], true, 0, 1.4417396042634078e-5, 3.2814979945494535e-8, :subcritical)\n\njulia> η(orc_ihex,sol_ihex)\n-0.09082835333090268\n\n(Image: ORC_economizer_example_cycle)","category":"section"},{"location":"examples/#Mixtures","page":"Examples","title":"Mixtures","text":"To use mixtures (multi-component) models for Clapeyron, construct the fluid with the desired components and ensure z to be the moles of each component and pass it to the cycle. In terms of solving, the difference with respect to pure fluids is that now there is a possibility of pinch point to be in two-phase. Hence we discretize the phase change zones.\n\njulia> using Clapeyron, ThermoCycleGlides\n\njulia> fluid = cPR([\"propane\",\"butane\"],idealmodel = ReidIdeal);\n\njulia> η_comp = 0.75; pp_cond = 2; pp_evap = 2;\n\njulia>  T_evap_in = 273.15 + 10; T_evap_out = 273.15 + 0; T_cond_in = 273.15 + 50;  T_cond_out = 273.15+60;\n\njulia> ΔT_sc = 3; ΔT_sh = 10;\n\njulia>  hp = HeatPump(fluid=fluid,z=[1.0,1.0],T_evap_in=T_evap_in,T_evap_out = T_evap_out,T_cond_in = T_cond_in,T_cond_out=T_cond_out,η_comp=η_comp,pp_evap=pp_evap,pp_cond=pp_cond,ΔT_sc = ΔT_sc,ΔT_sh = ΔT_sh);\n\njulia> sol_hp = solve(hp,ThermoCycleParameters(autodiff=false))\nSolutionState{Float64, Int64}([1.5812457906456645, 11.770249683622305], 20, 4, [4.746425474877469e-11, -1.3073986337985843e-12], [1.0706541681245205, 1.0706541681245205], [14.486154094902748, 14.486154094902748], false, 2, 4.0127165888769095e-8, 4.748225742363393e-11, :subcritical)\n\njulia> show(sol_hp)\nIterations: 4\nFunction calls: 20\nFinal residuals: [4.746425474877469e-11, -1.3073986337985843e-12]\nFinal residual norm: 4.748225742363393e-11\nFinal x: [1.5812457906456645, 11.770249683622305]\nFinal lenx ||xn - xk||/||xk||: 4.0127165888769095e-8\nFinal lenf ||f(xn)||: 4.748225742363393e-11\nLower bounds: [1.0706541681245205, 1.0706541681245205]\nUpper bounds: [14.486154094902748, 14.486154094902748]\nAutodiff: false\nFinite difference order: 2\nSolution type: subcritical","category":"section"},{"location":"examples/#Plotting","page":"Examples","title":"Plotting","text":"To plot the cycle use the following API: \n\nplot_cycle(prob::ThermoCycleProblem,sol::SolutionState,N=100)","category":"section"},{"location":"examples/#Limitation","page":"Examples","title":"Limitation","text":"Fluid models are limited to the ones provided by default in Clapeyron.jl\nFor now the solver is stable for sub-critical parameters. So if incase the solver does converge please check if the parameters provided allow the solution to be subcritical. \nFor mixtures, it is recommended to use parameters sufficently below the critical point.  \nIf for solving autodiff = true then for the first run there will be some compile time. Subsequent runs will be faster. ","category":"section"},{"location":"reference/#References","page":"References","title":"References","text":"","category":"section"},{"location":"reference/#Contents","page":"References","title":"Contents","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Index","page":"References","title":"Index","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#ThermoCycleGlides.HeatPump","page":"References","title":"ThermoCycleGlides.HeatPump","text":"HeatPump{T<:Real} <: ThermoCycleProblem\n\nA mutable structure representing a vapour-compression heat pump thermodynamic problem.\n\nFields\n\nfluid::EoSModel: The equation of state (EoS) model defining the working fluid thermodynamic properties. For now it has to be Cubic EoS.\nz::AbstractVector{T}: The composition vector of the working fluid (for mixtures; typically [1.0] for pure fluids).\nT_evap_in::T: Inlet temperature to the evaporator [K].\nT_evap_out::T: Outlet temperature from the evaporator [K].\nΔT_sh::T: Degree of superheating at the evaporator outlet [K].\nT_cond_in::T: Inlet temperature to the condenser [K].\nT_cond_out::T: Outlet temperature from the condenser [K].\nΔT_sc::T: Degree of subcooling at the condenser outlet [K].\nη_comp::T: Isentropic efficiency of the compressor [-].\npp_evap::T: Pinch point temperature difference for evaporator [K].\npp_cond::T: Pinch point temperature difference for condensor [K].\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.HeatPumpRecuperator","page":"References","title":"ThermoCycleGlides.HeatPumpRecuperator","text":"HeatPumpRecuperator{T<:Real} <: ThermoCycleProblem\n\nA mutable structure representing a heat pump cycle with an internal recuperator (economiser or heat exchanger) between the discharge and suction sides.\n\nFields\n\nhp::HeatPump{T}: The base heat pump configuration, containing fluid properties and cycle parameters.\nϵ::T: Effectiveness of the recuperator (dimensionless, typically between 0 and 1).\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.ORC","page":"References","title":"ThermoCycleGlides.ORC","text":"ORC{T<:Real} <: ThermoCycleProblem\n\nDefines an Organic Rankine Cycle (ORC) problem with thermodynamic and design  parameters specified in Kelvin and dimensionless efficiencies.\n\nFields\n\nfluid::CubicModel: Equation of State (EoS) model representing the working fluid. For now it has to be Cubic EoS.\nz::AbstractVector{T}: Mole fraction composition vector of the working fluid.\nT_evap_in::T: Inlet temperature of the evaporator [K].\nT_evap_out::T: Outlet temperature of the evaporator [K].\nΔT_sh::T: Degree of superheating at the expander inlet [K].\nT_cond_in::T: Inlet temperature of the condenser [K].\nT_cond_out::T: Outlet temperature of the condenser [K].\nΔT_sc::T: Degree of subcooling at the pump inlet [K].\nη_pump::T: Isentropic efficiency of the pump [-].\nη_expander::T: Isentropic efficiency of the expander [-].\npp_evap::T: Minimum temperature difference (pinch point) at the evaporator [K].\npp_cond::T: Minimum temperature difference (pinch point) at the condenser [K].\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.ORCEconomizer","page":"References","title":"ThermoCycleGlides.ORCEconomizer","text":"    ORCEconomizer{T<:Real} <: ThermoCycleProblem\n\nDefines an Organic Rankine Cycle (ORC) configuration with an economiser (regenerative heat exchanger), extending the base ORC problem with a specified effectiveness.\n\nFields\n\norc::ORC{T}: Base ORC system definition containing the thermodynamic parameters.\nϵ::T: Effectiveness of the economiser (regenerator) [-].\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.SolutionState","page":"References","title":"ThermoCycleGlides.SolutionState","text":"SolutionState -  A struct to hold the solution state of the nonlinear solver.\n\nx::Vector{T}: The solution vector.\nf_calls::I: The number of function calls made during the solving process.\niterations::I: The number of iterations taken to converge.\nresiduals::Vector{T}: The residuals at the solution.\nlb::Vector{T}: The lower bounds used in the solver.\nub::Vector{T}: The upper bounds used in the solver.\nautodiff::Bool: A flag indicating whether automatic differentiation was used.\nfd_order::I: The order of finite difference used if autodiff is false.\nlenx::T: The final change in the solution vector.\nlenf::T: The final change in the residuals.\nsoltype::Symbol: A symbol indicating the type of cycle (:unknown,:subcritical,:transcritical). This will be updated with the cycle type after solving.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.ThermoCycleParameters","page":"References","title":"ThermoCycleGlides.ThermoCycleParameters","text":"ThermoCycleParameters -  A struct to hold the solver parameters of the nonlinear solver.\n\nN::Int: Heat Exchanger discretization.\nmax_iters::Int: Maximum number of iterations\nautodiff::Bool: A flag indicating whether automatic differentiation was used.\nfd_order::Int: The order of finite difference used if autodiff is false.\nxtol::Real: convergece criteria on x.\nftol::Real: convergece criteria on f.\nrestart_TOL::Real: Restrat strategy with tolerace.\ninternal_pinch::Bool : Check for interal pinch for mixtures\n\n\n\n\n\n","category":"type"},{"location":"reference/#ThermoCycleGlides.COP-Tuple{ThermoCycleProblem, SolutionState}","page":"References","title":"ThermoCycleGlides.COP","text":"COP(prob::ThermoCycleGlides.ThermoCycleProblem, sol::SolutionState) -> Float64\n\nComputes the coefficient of performance (COP) of a thermodynamic cycle given the  problem definition and its corresponding solution state.\n\nArguments\n\nprob::ThermoCycleGlides.ThermoCycleProblem: The thermodynamic cycle problem  containing fluid models, boundary conditions, and component parameters.\nsol::SolutionState: The solution state object containing the converged  state variables (x), residuals, and convergence information.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.F-Union{Tuple{T}, Tuple{HeatPump, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.F","text":"F(prob::HeatPump, x::AbstractVector{T}; N::Int) function call to HeatPump\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.F-Union{Tuple{T}, Tuple{HeatPumpRecuperator, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.F","text":"F(prob::HeatPumpRecuperator, x::AbstractVector{T}; N::Int) function call to HeatPump\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{HeatPumpRecuperator}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::HeatPumpRecuperator) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{HeatPump}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::HeatPump) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{ORCEconomizer}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::ORCEconomizer) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_box_solve_bounds-Tuple{ORC}","page":"References","title":"ThermoCycleGlides.generate_box_solve_bounds","text":"generate_box_solve_bounds(prob::ORC) -> lb, ub Generates lower and upper bounds for the heat pump problem based on its parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{HeatPump, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::HeatPump,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{HeatPumpRecuperator, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::HeatPumpRecuperator,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{ORC, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::ORC,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.generate_initial_point-Union{Tuple{T}, Tuple{ORCEconomizer, AbstractVector{T}, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.generate_initial_point","text":"generate_initial_point(prob::ORCEconomizer,lb::AbstractVector{T},ub::AbstractVector{T})  Generates initial point for solving the system.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.optimize-Tuple{ThermoCycleProblem, Metaheuristics.Algorithm}","page":"References","title":"ThermoCycleGlides.optimize","text":"optimize(prob::ThermoCycleProblem; kwargs...)\n\nIts goal is to find the optimal subcooling and superheating values that maximize the cycle performance (COP or ORC -efficiency).\n\nThis should return the optimized cycle struct and the result from Metaheuristics\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.power_ratings-Union{Tuple{T}, Tuple{HeatPump, AbstractVector{T}}} where T","page":"References","title":"ThermoCycleGlides.power_ratings","text":"Function that gives specific power ratings for HP by fixing outlet power of compressor to equal 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.power_ratings-Union{Tuple{T}, Tuple{HeatPumpRecuperator, AbstractVector{T}}} where T","page":"References","title":"ThermoCycleGlides.power_ratings","text":"Function that gives specific power ratings for HP by fixing outlet power of compressor to equal 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.power_ratings-Union{Tuple{T}, Tuple{ORC, AbstractVector{T}}} where T","page":"References","title":"ThermoCycleGlides.power_ratings","text":"Function that gives specific power ratings for ORC by fixing outlet power of expander to equal 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.show_parameters-Tuple{ORC}","page":"References","title":"ThermoCycleGlides.show_parameters","text":"show_parameters(prob::ORC) prints parameters in REPL\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.solve-Tuple{ThermoCycleProblem, ThermoCycleParameters}","page":"References","title":"ThermoCycleGlides.solve","text":"Solves for pressure values in HP and ORC cycles for the given glide and problem parameters.  Define those problems in the respective structs.  For now the default box-nonlinear solver is newton-raphson, but this can be changed to other solvers in the future.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.solve-Tuple{ThermoCycleProblem}","page":"References","title":"ThermoCycleGlides.solve","text":"Solves for pressure values in HP and ORC cycles for the given glide and problem parameters.  Define those problems in the respective structs.  For now the default box-nonlinear solver is newton-raphson, but this can be changed to other solvers in the future.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.η-Tuple{ThermoCycleProblem, SolutionState}","page":"References","title":"ThermoCycleGlides.η","text":"η(prob::ThermoCycleGlides.ThermoCycleProblem, sol::SolutionState) -> Float64\n\nComputes the thermal efficiency of a thermodynamic cycle given a problem definition  and its corresponding solution state.\n\nArguments\n\nprob::ThermoCycleGlides.ThermoCycleProblem: The thermodynamic cycle problem  containing fluid properties, boundary conditions, and component parameters.\nsol::SolutionState: The solution state object containing the converged  state variables (x), residuals, and convergence information.\n\nReturns\n\nFloat64: The computed cycle efficiency, defined as the ratio of net work  output to heat input.\n\nNotes\n\nThis method acts as a wrapper that extracts the solution vector x from  sol and calls the lower-level η(prob, x) implementation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#ThermoCycleGlides.η-Union{Tuple{T}, Tuple{ORC, AbstractVector{T}}} where T<:Real","page":"References","title":"ThermoCycleGlides.η","text":"p[1] -> condensor pressure p[2] -> evaporator pressure\n\n\n\n\n\n","category":"method"},{"location":"#ThermoCycleGlides.jl","page":"Home","title":"ThermoCycleGlides.jl","text":"Documentation of ThermoCycleGlides.jl.\n\nThe goal of this package is to provide a non-linear solver for Heat Pump and Organic Rankine Cycle systems. It solves for pressures at the evaporator and the condensor for given pinch-point temperatures and provides a framework for plotting the solution.  As of now the package is robust for subcritical cycle parameters. For thermodynamic properties, Clapeyron.jl is used as backend. \n\nFor details of modeling see: Carnot batteries for heat and power coupling: Energy, Exergy, Economic and Environmental (4E) analysis - Laterre, Antoine, which describes modeling for pure fluids. This package extends the method for mixtures. \n\nThe nonlinear solver chosen is Newton-Raphson with box bounds which is inspired by the implementation in NLboxsolve.jl.\n\nThis package only supports steady-state applications.\n\nThere are 4 systems provided: \n\nOrganic Rankine Cycle : ORC\nOrganic Rankine Cycle with internal heat exchanger : ORCEconomizer\nHeat Pump : HeatPump\nHeat Pump with internal heat exchanger : HeatPumpRecuperator \n\nThe implemented version of these systems consist of the following components:\n\nCompressor : Modelling with isentropic efficiency   \nExpander : Modelling with isentropic efficiency\nValve : Modeled as isenthalpic process\nEvaporator : Volumes of equal change in enthalpy.\nCondenser : Volumes of equal change in enthalpy.\nHeat Exchangers (no phase change) : using epsilon as effectiveness of heat exchanger. ","category":"section"}]
}
